<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>hserus5</title>
  <style>
    body { font-family: Arial, sans-serif; background: #111; color: #eee; text-align: center; }
    h1 { color: #0ff; }
    table { width: 95%; margin: 20px auto; border-collapse: collapse; background: #222; }
    th, td { padding: 8px; border: 1px solid #444; text-align: center; }
    th { background: #333; cursor: pointer; }
    tr:nth-child(even) { background: #2a2a2a; }
    button { padding: 10px 20px; margin: 10px; background: #0ff; border: none; cursor: pointer; border-radius: 5px; }
    button:hover { background: #0cc; }
    #progress { margin: 10px; color: #0f0; font-weight: bold; }
  </style>
</head>
<body>
  <h1>hserus5</h1>
  <button onclick="runScanner()">üîÑ Refresh</button>
  <div id="progress">Idle</div>
  
  <table id="scannerTable">
    <thead>
      <tr>
        <th>Symbol</th>
        <th onclick="sortTable(1)">Close % ‚¨ç</th>
        <th onclick="sortTable(2)">Volume % ‚¨ç</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
  
<script>
const API = "https://fapi.binance.com";

// --- Utility---
function bollingerBands(values, period = 20, mult = 2) {
  if (values.length < period) return null;
  let slice = values.slice(-period);
  let mean = slice.reduce((a, b) => a + b, 0) / period;
  let variance = slice.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / period;
  let stdDev = Math.sqrt(variance);
  return {
    middle: mean,
    upper: mean + mult * stdDev,
    lower: mean - mult * stdDev
  };
}

// --- Main ---
async function runScanner() {
  document.getElementById("progress").innerText = "Fetching symbols...";
  let symbols = await fetch(`${API}/fapi/v1/exchangeInfo`)
    .then(r => r.json())
    .then(d => d.symbols
      .filter(s => s.symbol.endsWith("USDT") && s.contractType === "PERPETUAL")
      .map(s => s.symbol)
    );

  // Limit to top 200 volatile (skip top 30 big cap manually)
  // We proxy volatility by 24h quote volume
  let tickers = await fetch(`${API}/fapi/v1/ticker/24hr`).then(r => r.json());
  let sorted = tickers
    .filter(t => symbols.includes(t.symbol))
    .sort((a, b) => parseFloat(b.quoteVolume) - parseFloat(a.quoteVolume))
    .slice(1, 201); // exclude top 30, take next 200

  let results = [];
  let i = 0;
  for (let t of sorted) {
    i++;
    document.getElementById("progress").innerText = `Scanning ${i}/${sorted.length} - ${t.symbol}`;
    try {
      let klines = await fetch(`${API}/fapi/v1/klines?symbol=${t.symbol}&interval=1h&limit=25`).then(r => r.json());
      let closes = klines.map(k => parseFloat(k[4]));
      let highs = klines.map(k => parseFloat(k[2]));
      let lows = klines.map(k => parseFloat(k[3]));
      let vols = klines.map(k => parseFloat(k[5]));

      let bb = bollingerBands(closes);
      if (!bb) continue;

      let n = closes.length;
      let prevHigh = highs[n-2], prevLow = lows[n-2];
      let prevClose = closes[n-2];
      let curOpen = parseFloat(klines[n-1][1]);
      let curClose = closes[n-1];
      let curHigh = highs[n-1], curLow = lows[n-1];
      let prevBB = bollingerBands(closes.slice(0, n-1));

      let isGreen = curClose > curOpen;
      let cond1 = false, cond2 = false;

      if (isGreen) {
        cond1 = highs[n-2] < bb.upper && highs[n-3] < bb.upper;
        cond2 = curHigh > prevBB.upper;
      } else {
        cond1 = lows[n-2] > bb.lower && lows[n-3] > bb.lower;
        cond2 = curLow < prevBB.lower;
      }

      if (cond1 && cond2) {
        let closeChange = ((curClose - prevClose) / prevClose * 100).toFixed(2);
        let volChange = ((vols[n-1] - vols[n-2]) / vols[n-2] * 100).toFixed(2);
        results.push({symbol: t.symbol, closeChange, volChange});
      }
    } catch(e) { console.error(t.symbol, e); }
  }

  renderTable(results);
  document.getElementById("progress").innerText = "Scan complete ‚úî";
}

// --- Render Table ---
function renderTable(data) {
  let tbody = document.querySelector("#scannerTable tbody");
  tbody.innerHTML = "";
  data.forEach(r => {
    let row = `<tr>
      <td>${r.symbol}</td>
      <td>${r.closeChange}%</td>
      <td>${r.volChange}%</td>
    </tr>`;
    tbody.innerHTML += row;
  });
}

// --- Sorting ---
function sortTable(colIndex) {
  let table = document.getElementById("scannerTable");
  let rows = Array.from(table.rows).slice(1);
  let asc = table.getAttribute("data-sort") !== "asc";
  rows.sort((a, b) => {
    let x = parseFloat(a.cells[colIndex].innerText);
    let y = parseFloat(b.cells[colIndex].innerText);
    return asc ? x - y : y - x;
  });
  rows.forEach(r => table.tBodies[0].appendChild(r));
  table.setAttribute("data-sort", asc ? "asc" : "desc");
}
</script>
</body>
</html>
